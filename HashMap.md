## 1、HashMap的底层数据结构是什么？

JDK1.7中，由“数组+链表”组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在。

JDK1.8中，有“数组+链表+红黑树”组成。当链表过长，则会严重影响HashMap的性能，红黑树搜索时间复杂度是O(logn)，而链表是O(n)。因此，JDK1.8对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：

- 当链表超过8且数组长度(数据总量)超过64才会转为红黑树
- 将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。
- ![图片](https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIOtETfibvQv676xq7sxYRL96fodZeQ7NJjVUrxpbXiaKicVqlcgcsLicuBCrFXXCwG6FWqic3fUX3ia0iaXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 2、说一下HashMap的特点

- HashMap存取是无序的
- 键和值位置都可以是null，但是键位置只能有一个null
- 键位置唯一，底层的数据结构是控制键的
- jdk1.8前数据结构是：链表+数组。jdk1.8后是：数组+链表+红黑树。
- 阈值（边界值）>8并且数组长度大于64时，才将链表转换为红黑树，变为红黑树的目的是提高搜索速度，高效查询。

## 3、解决hash冲突的方法有哪些？

开放地址法、再哈希法、链地址法（HashMap中常见的拉链法）、建立公共溢出区。HashMap中采用的是链地址法。

- 开放地址法也称为再散列法，基本思想是：如果发生冲突了，就在散列表（数组中）寻找合适的位置存储。什么是合适的位置呢？有以下方法寻找合适的位置：线性探测法、平方探测法。

  线性探测法：当前位置冲突就寻找相邻的下一个位置。（(hash(key)+i)%m）,i递增且小于m。

  平方探测法：当前位置冲突使用i^2（i的平方）进行跳跃寻找下一个位置。（(hash(key)+i^2)%m）,i递增且小于m。

- 再哈希法（双重散列，多重散列），提供多个不同的hash函数，R1=H1(key1)发生冲突时，再计算R2=H2（key1），直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算的时间。

- 链地址法（拉链法），将哈希值相同的元素构成一个同义词的单链法，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行，链表法适用于经常进行插入和删除的情况。

- 建立公共溢出区：将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

## 4. 为什么要在数组长度大于64之后，链表才会进化为红黑树

转化为红黑树是为了加快搜索速度。提高性能。

JDK1.8以前HashMap的实现是数组+链表，即使哈希函数取的再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放在同一个桶中时，这个桶下有一条